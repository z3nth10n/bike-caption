<?php

require "settings.php";
require "vendor/autoload.php";
use PHPHtmlParser\Dom;
use Nesk\Puphpeteer\Puppeteer;
use Nesk\Rialto\Data\JsFunction;
use Nesk\Puphpeteer\Resources\Page;

$bike_urls = [
	"https://es.wikiloc.com/rutas-ciclismo/ruta-bici-i-48880916",
	"https://es.wikiloc.com/rutas-ciclismo/ruta-bici-2-48880929"
];

$puppeteerInstance = null; $browserInstance = null; $pageInstance = null;

function getDom() {
	global $bike_urls, $email, $password, $browserInstance;

	$page = launchPuppeteer([ 'read_timeout' => 65 ]);
	$page->goto($bike_urls[0], [
        	'timeout' => 60000, // In milliseconds
    	]);

	// $page->find("#email")[0]->text($email);
	/*
	$page->type("#email", $email, ['delay' => 100]);
	$page->type("#password", '23333300FF', ['delay' => 100]);
	// setText('password', 'hola');
	submit('login');
	*/

	$page->type('[name=email]', $email);
	$page->type('[name=password]', $password);
	// $page->tryCatch->click('#submit-button');
	$page->click('[type=submit]');
	$page->waitForNavigation([ 'waitUntil' => 'networkidle0' ]);

	// submit('login');
	// $page->waitContext()->waitFor('#trail-data');
	// $page->waitForNavigation();
	// $page->click("#submit-button")->waitForNavigation(['waitUntil'=> 'load']);

	/*setText("email", $email);
	setText("password", $password);
	getElement("submit-button")->click();*/

	$dom = new Dom;
	$dom->load($page->content());
	echo $dom->outerHtml; 

	// $html = $dom->outerHtml;

	$traildata = $dom->find('#trail-data')[0];
	/*$moredata = $traildata->find('.more-data')[0];
	$moredata->delete();
	unset($moredata);*/
	$traildata = $traildata->outerHtml;

	$elevationprofile = $dom->find('#elevation-profile')[0];
	$elevationprofile = $elevationprofile->outerHtml;

	$browserInstance->close();

	return $traildata + $elevationprofile;
}

function setText($id, $text) {

	// document.getElementById('".$id."').value = '".$text."';

	global $pageInstance;

	$pageInstance->evaluate(JsFunction::createWithBody("
	    $('#".$id."').val('".$text."');
	"));
}

function submit($id) {
	global $pageInstance;
	$pageInstance->evaluate(JsFunction::createWithBody("
	    document.getElementById('".$id."').submit();
	"));
}

function getElement($id) {
	global $pageInstance;
	$pageInstance->evaluate(JsFunction::createWithBody("
	    return document.getElementById('".$id."');
	"));
}

// document.documentElement.innerHTML

function dom() {
	global $pageInstance;
	$pageInstance->evaluate(JsFunction::createWithBody("
	    return document.documentElement.innerHTML;
	"));
}

function launchPuppeteer($args, $disable = false) {
    global $puppeteerInstance, $browserInstance, $pageInstance;

    // bugfix: Don't create instance if it's already created!
    if(isset($puppeteerInstance) && isset($browserInstance) && isset($pageInstance)) {
        echo "Reusing instance...".PHP_EOL;
        return $pageInstance;
    }

    $arg = $disable ? ['--no-sandbox', '--disable-setuid-sandbox'] : ['--no-sandbox'];
    $puppeteerInstance = !isset($args) ? new Puppeteer : new Puppeteer($args);
    $browserInstance = $puppeteerInstance->launch([
               'args' => $arg,
               'headless' => true
    ]);

    // $pageInstance = new WaitPageDecorator($browserInstance->newPage());
    $pageInstance = $browserInstance->newPage();

    return $pageInstance;
}

class WaitPageDecorator
{
    private Page $page;
    private int $throttleThreshold;
    private string $lastExecContextId;

    public function __construct(Page $page, int $throttleThreshold = 2222500)
    {
        $this->page = $page;
        $this->throttleThreshold = $throttleThreshold;
    }

    public function __call($name, $arguments)
    {
        if (substr($name, 0, 4) === 'wait') {
            return call_user_func_array([$this, $name], $arguments);
        }

        return call_user_func_array([$this->page, $name], $arguments);
    }

    public function waitContext(): self
    {
        $execContextId = $this->waitExecContextId();

        if (!isset($this->lastExecContextId)) {
            $this->lastExecContextId = $execContextId;
        }

        while ($execContextId === $this->lastExecContextId) {
            $this->waitThrottle();
            $execContextId = $this->waitExecContextId();
        }

        return $this;
    }

    public function waitFor(string $selector, int $timeout = 30): self
    {
        // TODO: Implement timeout

        while (!$this->waitContains($selector)) {
            $this->waitThrottle();
        }

        return $this;
    }

    public function waitEval(string $selector, string $jsFuncBody): string
    {
        return $this->page->querySelectorEval($selector, JsFunction::createWithParameters(['elem'])->body($jsFuncBody));
    }

    public function waitContains(string $selector): bool
    {
        $bodyHtml = $this->waitEval('body', 'return elem.innerHTML');
        $crawler = new Crawler($bodyHtml);
        return $crawler->filter($selector)->count() > 0;
    }


    private function waitExecContextId(): string
    {
        /** @var ExecutionContext $context */
        $context = $this->page->mainFrame()->executionContext();
        return $context->getResourceIdentity()->uniqueIdentifier();
    }

    private function waitThrottle(): void
    {
        usleep($this->throttleThreshold);
    }

    public function type($sel, $value) {
    	$this->page->tryCatch->type($sel, $value);
    }

    public function click($sel) {
    	$this->page->tryCatch->click($sel);
    }
}